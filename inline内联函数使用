inline定义格式
一、inline关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义。
表达式形式的宏定义如：
#define ExpressionName(Var1,Var2) ((Var1)+(Var2))*((Var1)-(Var2))
取代这种形式的原因如下：
1．C中使用define这种形式宏定义的原因是因为，C语言是一个效率很高的语言，这种宏定义在形式及使用上像一个函数，但它使用预处理器实现，没有了参数压栈，代码生成等一系列的操作。因此，效率很高，这是它在C中被使用的一个主要原因。
2．这种宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型。这样，它的使用就存在着一系列的隐患和局限性。
3．在C++中引入了类及类的访问控制，这样，如果一个操作或者说一个表达式涉及到类的保护成员或私有成员，你就不可能使用这种宏定义来实现（因为无法将this指针放在合适的位置）。
4．inline推出的目的，也正是为了取代这种表达式形式的宏定义，它消除了宏定义的缺点，同时又很好地继承了宏定义的优点。
预定义
对应于上面的1-3点，阐述如下：
1．inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换（像宏一样展开），没有了调用的开销，效率也很高。
2．很明显，类的内联函数也是一个真正的函数，编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。
3．inline可以作为某个类的成员函数，当然就可以在其中使用所在类的保护成员及私有成员。
在何时使用inline函数：
首先，你可以使用inline函数完全取代表达式形式的宏定义。
另外要注意，内联函数一般只会用在函数内容非常简单的时候。这是因为，内联函数的代码会在任何调用它的地方展开，如果函数太复杂，代码膨胀带来的恶果很可能会大于效率的提高带来的益处。内联函数最重要的使用地方是用于类的存取函数。 [2] 
功能及注意事项编辑
（1）内联函数的作用
●对于内联函数，C++有可能直接用函数体代码来替代对函数的调用，这一过程称为函数体的内联展开。
●对于只有几条语句的小函数来说，与函数的调用、返回有关的准备和收尾工作的代码往往比函数体本身的代码要大得多。因此，对于这类简单的、使用频繁的小函数，将之说明为内联函数可提高运行效率。 [3] 
（2）慎用内联函数
内联是以代码膨胀复制为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码, 将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：
1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 [4] 
内联函数与一般函数区别编辑
1）内联含函数比一般函数在前面多一个inline修饰符。
2）内联函数是直接复制“镶嵌”到主函数中去的，就是将内联函数的代码直接放在内联函数的位置上，这与一般函数不同，主函数在调用一般函数的时候，是指令跳转到被调用函数的入口地址，执行完被调用函数后，指令再跳转回主函数上继续执行后面的代码；而由于内联函数是将函数的代码直接放在了函数的位置上，所以没有指令跳转，指令按顺序执行。
3）一般函数的代码段只有一份，放在内存中的某个位置上，当程序调用它是，指令就跳转过来；当下一次程序调用它是，指令又跳转过来；而内联函数是程序中调用几次内联函数，内联函数的代码就会复制几份放在对应的位置上
4）内联函数一般在头文件中定义，而一般函数在头文件中声明，在cpp中定义。
使用方法编辑
inline的使用：
1．在类中定义这种函数：
class ClassName{
.....
....
INT GetWidth(){return m_lPicWidth;}; // 如果在类中直接定义，不需要用inline修饰，编译器自动化为内联函数
.... //此说法在《C++ Primer》中提及
....
}
2．在类外定义前加inline关键字：

class Account {
public:
Account(double initial_balance) { balance = initial_balance; } //与1相同
double GetBalance(); //在类中声明
double Deposit( double Amount );
double Withdraw( double Amount );
private:
double balance;
};
inline double Account::GetBalance() { return balance; } //在类外定义时添加inline关键字
inline double Account::Deposit( double Amount ) { return ( balance += Amount ); }
inline double Account::Withdraw( double Amount ) { return ( balance -= Amount ); }
此外还有一些规则需注意：
1．inline说明对编译器来说只是一种建议，编译器可以选择忽略这个建议。比如，你将一个长达1000多行的函数指定为inline，编译器就会忽略这个inline，将这个函数还原成普通函数。
2．在调用内联函数时，要保证内联函数的定义让编译器"看"到，也就是说内联函数的定义要在头文件中，这与通常的函数定义不一样。但如果你习惯将函数定义放在CPP文件中，或者想让头文件更简洁一点，可这样做：
1
//SomeInline.h中

#ifndef SOMEINLINE_H
#define SOMEINLINE_H
Type Example(void);
//........其他函数的声明
#include"SomeInlie.cpp" //源文件后缀名随编译器而定
#endif
//SomeInline.cpp中
#include"SomeInline.h"
inline Type Example(void)
{
//..........
}
//...............其他函数的定义
以上方法是通用、有效的，可放心使用，不必担心在头文件包含CPP文件会导致编译错误。 [2] 
InLine hook编辑
原理
Inline-Hook通过修改函数的流程, 跳转至自定义的流程，再跳回原函数，以保证系统不崩溃，实现代码逻辑的篡改。 [5]  如图所示：

首先将目标指令替换为跳转指令，跳转地址为一段我们自己编写的汇编代码，这段汇编代码先是执行用户指定的代码，如修改寄存器的值，然后执行被替换掉的原指令2，最后再跳转回原指令3处，恢复程序的正常运行。
流程
（1）构造跳转指令。
（2）在内存中找到欲HOOK函数地址，并保存欲HOOK位置处的前5个字节。
（3）将构造的跳转指令写入需HOOK的位置处。
（4）当被HOOK位置被执行时会转到我们的流程执行。
（5）如果要执行原来的流程，那么取消HOOK，也就是还原被修改的字节。
（6）执行原来的流程。
（7）继续HOOK住原来的位置。
