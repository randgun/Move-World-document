[github]关于在仓库中创建文件的方法举例
直接在文件名后加"\"，github会自动识别为文件夹，但注意不能创建一个空文件夹。

[C++]关于Qt的下载安装
下载地址：https://download.qt.io/archive/
既可以下载vsaddin作为VS的Qt插件
也可下载完整的Qt
安装过程：傻瓜式默认安装

[C++] VS2017多文件编译时出现ERROR:
error LNK2019:无法解析的外部符号……………该符号在函数_main中被引用 
解决方法:检查需要编译的文件是不是有没添加到项目中的，同一个文件内的文件也不一定是在同一个项目中。(我是SB)

[C++] 关于析构函数不建议使用inline。
因为内联函数一般用于实现简单的功能，而析构函数一般比表面看起来要复杂得多(就像是个什么都不做的空函数，实则不然)，
经VS2017测试,若析构函数使用inline，编译不通过。

[C++] 关于类的对象(类的实例)创建
如果既可以通过初始化，也可以通过赋值来设置对象的值，则应该采用初始化方式，通常这种方式效率更高。
Eg:class Stock{……};
Stock stock = Stock(…) //可能会创建临时对象，也可能不会(取决于编译器)
stock = Stock(…) //赋值前总会先创建一个临时对象，然后再销毁(过程中会调用析构函数)

[C++]关于用new创建的动态类对象
如果对象是new创建的，则它将在栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用，即需要手动delete对象。
Eg: Stock *pstock = new Stock {};
	delete pstock;  //需要手动delete

[C++] 使用char数组保存字符串时，如果是单独存储每个字符，需要手动在末尾补’\0’，表示字符串结束，
如char a[];a[0]=’a’,a[1]=’b’,a[2]=’\0’；若是char a[]=”adsfsf”，字符串末尾默认加“\0”

[C++] 在VC2005之后，使用字符串拷贝函数strcpy会提示该函数不安全，将来会被抛弃类似这样的信息。
所以一般都会改用strcpy_s函数代替。有时会出现这样的提示错误：“buffer is too small …… ”
解决方法:
strcpy_s(A,strlen(B)+1,B)
因为strlen()计算的长度不包括’/0’，第二个参数设置值需大于strlen(B)+1，小于A的大小。

[C++]关于const的一些问题
const int a; int const a; 这两个写法是等同的，表示a是一个int常量。
const int *a; 表示a是一个指针，可以任意指向int常量或者int变量，它总
是把它所指向的目标当作一个int常量。也可以写成int const*
a;含义相同。
int * const a; 表示a是一个指针常量，初始化的时候必须固定指向一个int变
量，之后就不能再指向别的地方了。

[C++]类的数据成员私有性是针对类而言的(即private，protected，public用于限定类而非对象)，而同一类的不同对象都是可以直接访问私有成员变量的。
Eg:class A {private:int a,b,c;	public:void add(int x,int y);};
A::A(const A& B){a+=B.x}
至于不同类之间的私有成员访问，可采用声明友元函数等方式实现。
