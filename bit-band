如何不用stm自带的库函数定义来自己通过位带操作读取某个特定io口的状态？
首先解释一下什么是位带操作：
在stm32芯片中，有两个区实现了位带。其中一个是SARM区的最低1MB范围（0x2000_0000-0x200F_FFFF），
另外一个则是片内外设区的最低1MB范围（0x4000_0000-0x400F_FFFF），这两个区都有自己的“位带别名区”，
位带别名区把每个bit都膨胀成一个32位的字，所以通过访问这些位带别名区的字时，就可以达到访问原始比特的目的。

由上可推导出位带区的地址映射到别名区的公式为：
SARM：Addr=0x2200_0000+（（位带区地址-0x2000_0000）*8+对应位带区地址所要读取的比特位n）*4；
片内外设区：Addr=0x4200_0000+（（位带区地址-0x4000_0000）*8+对应位带区地址所要读取的比特位n）*4；

注意：由于在位带别名区中，每个字都是只有LSB有效的字，所以在映射地址时一定要注意把目标地址对齐到字的边界上（即映射后的地址尾数必须是0、4、8、C）。
      而在C语言中，由于C编译器中并没有直接支持位操作，所以要用“define”将别名区的地址转换成指针类型，而且定义的变量要用“volatile”来定义。


在stm32中，外设所在的地址正是处于片内外设区的最低1MB范围，
所以映射时要套用的公式即为“Addr=0x4200_0000+（（位带区地址-0x4000_0000）*8+对应位带区地址所要读取的比特位n）*4；”。
而在编程的时候，此公式可简写为：
Addr=（位带区地址&0xF000_0000）+0x200_0000+（（位带区地址&0xF_FFFF）<<5）+（n<<2）


举例（读取GPIOA7的状态）：
首先通过《参考手册》查到GPIOA_IDR的地址为0x4001_0808，此地址即为位带区地址，
而由于是GPIOA7，所以n=7，
接着套用公式Addr=（位带区地址&0xF000_0000）+0x200_0000+（（位带区地址&0xF_FFFF）<<5）+（n<<2），
得到的Addr即为位带别名区的地址，最后再通过define：
#define PAin（7） *（（volatile unsigned long *） （Addr））
即可通过PAin（7）读取GPIOA7的状态了。
